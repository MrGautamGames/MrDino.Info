<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape Shifters - MrDino.Info</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #6b7280, #4c1d95);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255,255,255,0.1), transparent);
            z-index: -1;
            animation: pulse 10s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .start-screen, .game-over-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(107, 114, 128, 0.9), rgba(76, 29, 149, 0.9));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .logo {
            font-size: 3.5rem;
            font-weight: 700;
            color: #facc15;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 1rem;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .subtitle {
            font-size: 1.25rem;
            margin-bottom: 2rem;
            color: #e5e7eb;
            font-weight: 400;
        }

        .start-btn, .restart-btn {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            background: linear-gradient(45deg, #ef4444, #f97316);
            color: white;
            border: none;
            border-radius: 9999px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.3s, box-shadow 0.3s;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
        }

        .start-btn:hover, .restart-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .game-canvas {
            width: 100%;
            height: 70%;
            background: linear-gradient(180deg, #7dd3fc, #4ade80);
            border: 3px solid #3b82f6;
            position: relative;
        }

        .ui-panel {
            height: 30%;
            background: linear-gradient(135deg, #3b82f6, #a855f7);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            color: white;
            font-weight: 600;
            font-size: 1.25rem;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .question-area {
            text-align: center;
            color: white;
            font-size: 1.125rem;
            font-weight: 600;
            background: rgba(255,255,255,0.2);
            border-radius: 0.75rem;
            padding: 0.75rem;
            margin: 0.75rem 0;
        }

        .shape-buttons {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .shape-btn {
            padding: 0.75rem;
            background: linear-gradient(45deg, #facc15, #f97316);
            border: 3px solid #ef4444;
            border-radius: 0.75rem;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            color: #7f1d1d;
            transition: all 0.3s;
            min-width: 100px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .shape-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .shape-btn.correct {
            background: linear-gradient(45deg, #22c55e, #86efac);
            animation: correctPulse 0.5s;
        }

        .shape-btn.wrong {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            animation: wrongShake 0.5s;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes wrongShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .powered-by {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            color: rgba(255,255,255,0.7);
            font-size: 0.75rem;
            z-index: 50;
        }

        .hearts {
            display: flex;
            gap: 0.25rem;
        }

        .heart {
            color: #ec4899;
            font-size: 1.5rem;
            animation: heartbeat 1.5s infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .progress-bar {
            width: 100%;
            height: 0.75rem;
            background: rgba(255,255,255,0.3);
            border-radius: 0.375rem;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #facc15);
            width: 0%;
            transition: width 0.1s;
        }

        @media (max-width: 768px) {
            .logo { font-size: 2.5rem; }
            .stats { font-size: 1rem; }
            .shape-btn { min-width: 80px; font-size: 0.875rem; }
            .question-area { font-size: 1rem; }
            .start-btn, .restart-btn { font-size: 1.25rem; padding: 0.75rem 1.5rem; }
        }
    </style>
</head>
<body>
    <audio id="backgroundMusic" loop preload="auto">
        <source src="https://mrdino.info/Music/game-music-loop-4-144341.mp3" type="audio/mpeg">
    </audio>
    <div class="game-container">
        <div class="start-screen" id="startScreen">
            <div class="logo">ü¶ï MrDino.Info</div>
            <h1 class="text-4xl md:text-5xl font-bold text-yellow-400 mb-4">Shape Shifters</h1>
            <div class="subtitle">Transform shapes to survive! Learn geometry while you play!</div>
            <button class="start-btn" onclick="startGame()">üöÄ Start Adventure</button>
        </div>

        <canvas class="game-canvas" id="gameCanvas"></canvas>
        
        <div class="ui-panel">
            <div class="stats">
                <div>Score: <span id="score">0</span></div>
                <div>Level: <span id="level">1</span></div>
                <div class="hearts" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="question-area" id="questionArea">
                Get ready to transform shapes!
            </div>
            
            <div class="shape-buttons" id="shapeButtons"></div>
        </div>

        <div class="game-over-screen" id="gameOverScreen" style="display: none;">
            <div class="logo">ü¶ï MrDino.Info</div>
            <h1 class="text-3xl md:text-4xl font-bold text-yellow-400 mb-4">Game Over!</h1>
            <div class="text-xl md:text-2xl mb-6">Final Score: <span id="finalScore">0</span></div>
            <div class="mb-8">You reached Level <span id="finalLevel">1</span>!</div>
            <button class="restart-btn" onclick="restartGame()">üîÑ Play Again</button>
        </div>

        <div class="powered-by">Powered by MrDino.Info ü¶ï</div>
    </div>

    <script>
        // Audio setup with error handling
        const bgMusic = document.getElementById('backgroundMusic');
        const correctSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-correct-answer-reward-952.mp3');
        const wrongSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-wrong-answer-fail-notification-946.mp3');
        const gameOverSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-failure-arcade-240.mp3');

        // Audio error handling
        [bgMusic, correctSound, wrongSound, gameOverSound].forEach(audio => {
            audio.onerror = () => {
                console.warn(`Failed to load audio: ${audio.src || audio.currentSrc}. Audio will be muted for this element.`);
            };
            audio.preload = 'auto'; // Ensure audio is preloaded
        });

        // Game state variables
        let gameState = {
            score: 0,
            level: 1,
            lives: 3,
            isPlaying: false,
            currentQuestion: null,
            playerShape: 'square',
            playerX: 100,
            playerY: 200,
            obstacleX: 800,
            obstacleY: 200,
            speed: 2,
            answered: false,
            timeLeft: 100,
            merging: false,
            colliding: false,
            mergeProgress: 0,
            collisionShake: 0,
            playerScale: 1,
            obstacleScale: 1,
            particles: [],
            lastCorrectShape: null
        };

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            gameState.playerY = canvas.height / 2;
            gameState.obstacleY = canvas.height / 2;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Question database with increasing difficulty
        const questions = {
            easy: [
                {
                    question: "Which shape has 4 equal sides?",
                    correct: "square",
                    options: ["square", "rectangle", "triangle", "circle"]
                },
                {
                    question: "Which shape has no corners?",
                    correct: "circle",
                    options: ["square", "triangle", "circle", "rectangle"]
                },
                {
                    question: "Which shape has 3 sides?",
                    correct: "triangle",
                    options: ["square", "triangle", "pentagon", "circle"]
                }
            ],
            medium: [
                {
                    question: "Which shape has a perimeter of 20 units? (5√ó4)",
                    correct: "square",
                    options: ["square", "rectangle", "triangle", "pentagon"]
                },
                {
                    question: "Which shape has 90¬∞ angles?",
                    correct: "rectangle",
                    options: ["triangle", "rectangle", "pentagon", "circle"]
                },
                {
                    question: "Which shape has 5 sides?",
                    correct: "pentagon",
                    options: ["square", "triangle", "pentagon", "hexagon"]
                }
            ],
            hard: [
                {
                    question: "Which shape has an area of 36 square units? (6√ó6)",
                    correct: "square",
                    options: ["square", "rectangle", "triangle", "circle"]
                },
                {
                    question: "Which shape has 6 sides?",
                    correct: "hexagon",
                    options: ["pentagon", "hexagon", "octagon", "triangle"]
                },
                {
                    question: "Which shape has interior angles of 108¬∞?",
                    correct: "pentagon",
                    options: ["square", "pentagon", "hexagon", "octagon"]
                }
            ]
        };

        // Shape drawing functions
        function drawShape(x, y, shape, size = 40, color = '#ef4444') {
            ctx.fillStyle = color;
            ctx.strokeStyle = '#7f1d1d';
            ctx.lineWidth = 3;
            
            ctx.save();
            ctx.translate(x, y);
            
            switch(shape) {
                case 'square':
                    ctx.fillRect(-size/2, -size/2, size, size);
                    ctx.strokeRect(-size/2, -size/2, size, size);
                    break;
                    
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;
                    
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(-size/2, size/2);
                    ctx.lineTo(size/2, size/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                    
                case 'rectangle':
                    ctx.fillRect(-size/1.5, -size/2.5, size*1.3, size/1.2);
                    ctx.strokeRect(-size/1.5, -size/2.5, size*1.3, size/1.2);
                    break;
                    
                case 'pentagon':
                    drawPolygon(5, size/2);
                    break;
                    
                case 'hexagon':
                    drawPolygon(6, size/2);
                    break;
                    
                case 'octagon':
                    drawPolygon(8, size/2);
                    break;
            }
            ctx.restore();
        }

        function drawPolygon(sides, radius) {
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        // Game logic functions
        function getRandomQuestion() {
            let difficulty = 'easy';
            if (gameState.level >= 5) difficulty = 'hard';
            else if (gameState.level >= 3) difficulty = 'medium';
            
            const questionSet = questions[difficulty];
            let availableQuestions = questionSet.filter(q => q.correct !== gameState.lastCorrectShape);
            
            if (availableQuestions.length === 0) {
                availableQuestions = questionSet;
            }
            
            const selectedQuestion = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
            gameState.lastCorrectShape = selectedQuestion.correct;
            
            return selectedQuestion;
        }

        function generateNewObstacle() {
            gameState.currentQuestion = getRandomQuestion();
            gameState.obstacleX = canvas.width + 100;
            gameState.answered = false;
            gameState.timeLeft = 100;
            
            displayQuestion();
            createShapeButtons();
        }

        function displayQuestion() {
            document.getElementById('questionArea').textContent = gameState.currentQuestion.question;
        }

        function createShapeButtons() {
            const container = document.getElementById('shapeButtons');
            container.innerHTML = '';
            
            gameState.currentQuestion.options.forEach(shape => {
                const button = document.createElement('button');
                button.className = 'shape-btn';
                button.textContent = shape.charAt(0).toUpperCase() + shape.slice(1);
                button.onclick = () => selectShape(shape, button);
                container.appendChild(button);
            });
        }

        function selectShape(selectedShape, buttonElement) {
            if (gameState.answered) return;
            
            gameState.answered = true;
            const isCorrect = selectedShape === gameState.currentQuestion.correct;
            
            const buttons = document.querySelectorAll('.shape-btn');
            buttons.forEach(btn => {
                if (btn === buttonElement) {
                    btn.classList.add(isCorrect ? 'correct' : 'wrong');
                } else if (btn.textContent.toLowerCase() === gameState.currentQuestion.correct) {
                    btn.classList.add('correct');
                }
            });
            
            if (isCorrect) {
                correctSound.play().catch(err => console.warn('Correct sound playback failed:', err));
                gameState.score += 10 * gameState.level;
                gameState.playerShape = selectedShape;
                gameState.merging = true;
                startMergeAnimation();
                setTimeout(() => {
                    generateNewObstacle();
                    if (gameState.score % 100 === 0) levelUp();
                }, 2000);
            } else {
                wrongSound.play().catch(err => console.warn('Wrong sound playback failed:', err));
                gameState.colliding = true;
                startCollisionAnimation();
                loseLife();
            }
            
            updateUI();
        }

        function startMergeAnimation() {
            gameState.mergeProgress = 0;
            const mergeDuration = 120;
            
            const animateMerge = () => {
                gameState.mergeProgress++;
                
                if (gameState.mergeProgress <= mergeDuration) {
                    requestAnimationFrame(animateMerge);
                } else {
                    gameState.merging = false;
                    gameState.mergeProgress = 0;
                    gameState.playerScale = 1;
                    gameState.obstacleScale = 1;
                }
            };
            animateMerge();
        }

        function startCollisionAnimation() {
            gameState.collisionShake = 30;
            
            for (let i = 0; i < 15; i++) {
                gameState.particles.push({
                    x: gameState.playerX,
                    y: gameState.playerY,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 60,
                    maxLife: 60,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)`
                });
            }
            
            const animateCollision = () => {
                gameState.collisionShake--;
                
                if (gameState.collisionShake <= 0) {
                    gameState.colliding = false;
                    gameState.collisionShake = 0;
                } else {
                    requestAnimationFrame(animateCollision);
                }
            };
            animateCollision();
        }

        function loseLife() {
            gameState.lives--;
            if (gameState.lives <= 0) {
                setTimeout(() => endGame(), 1000);
            } else {
                setTimeout(() => {
                    generateNewObstacle();
                }, 2000);
            }
        }

        function levelUp() {
            gameState.level++;
            gameState.speed += 0.5;
            
            const questionArea = document.getElementById('questionArea');
            questionArea.textContent = `üéâ Level ${gameState.level} Unlocked! üéâ`;
            questionArea.style.background = 'linear-gradient(45deg, #facc15, #f97316)';
            
            setTimeout(() => {
                questionArea.style.background = 'rgba(255,255,255,0.2)';
            }, 2000);
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            
            const heartsContainer = document.getElementById('lives');
            heartsContainer.innerHTML = '‚ù§Ô∏è'.repeat(gameState.lives) + 'üñ§'.repeat(3 - gameState.lives);
            
            const progress = Math.max(0, (canvas.width - (gameState.obstacleX - gameState.playerX)) / canvas.width * 100);
            document.getElementById('progressFill').style.width = progress + '%';
        }

        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            
            if (!gameState.merging) {
                gameState.obstacleX -= gameState.speed;
            }
            
            if (gameState.merging) {
                handleMergeAnimation();
            }
            
            if (gameState.colliding) {
                handleCollisionAnimation();
            }
            
            updateParticles();
            
            let shakeX = 0, shakeY = 0;
            if (gameState.collisionShake > 0) {
                const intensity = gameState.collisionShake / 30;
                shakeX = (Math.random() - 0.5) * 20 * intensity;
                shakeY = (Math.random() - 0.5) * 20 * intensity;
            }
            
            drawShape(
                gameState.playerX + shakeX, 
                gameState.playerY + shakeY, 
                gameState.playerShape, 
                50 * gameState.playerScale, 
                gameState.colliding ? '#ec4899' : '#22c55e'
            );
            
            if (gameState.currentQuestion) {
                const obstacleColor = gameState.merging ? '#86efac' : '#ef4444';
                drawShape(
                    gameState.obstacleX, 
                    gameState.obstacleY, 
                    gameState.currentQuestion.correct, 
                    60 * gameState.obstacleScale, 
                    obstacleColor
                );
                
                if (!gameState.merging) {
                    ctx.fillStyle = '#facc15';
                    ctx.font = 'bold 30px Poppins';
                    ctx.textAlign = 'center';
                    ctx.fillText('?', gameState.obstacleX, gameState.obstacleY - 60);
                }
            }
            
            if (gameState.obstacleX < gameState.playerX + 50 && !gameState.answered && !gameState.merging) {
                gameState.colliding = true;
                startCollisionAnimation();
                loseLife();
            } else if (gameState.obstacleX < -100 && !gameState.merging) {
                generateNewObstacle();
            }
            
            gameState.timeLeft = Math.max(0, gameState.timeLeft - 0.5);
            
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function handleMergeAnimation() {
            const progress = gameState.mergeProgress / 120;
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            
            const targetDistance = 80;
            const currentDistance = gameState.obstacleX - gameState.playerX;
            if (currentDistance > targetDistance) {
                gameState.obstacleX = gameState.playerX + targetDistance + (currentDistance - targetDistance) * (1 - easeProgress);
            }
            
            if (progress < 0.5) {
                const scaleProgress = progress / 0.5;
                gameState.playerScale = 1 + scaleProgress * 0.5;
                gameState.obstacleScale = 1 + scaleProgress * 0.5;
            } else {
                const mergeProgress = (progress - 0.5) / 0.5;
                gameState.playerScale = 1.5 - mergeProgress * 0.5;
                gameState.obstacleScale = 1.5 - mergeProgress * 1.5;
                
                if (Math.random() < 0.3) {
                    const midX = (gameState.playerX + gameState.obstacleX) / 2;
                    const midY = (gameState.playerY + gameState.obstacleY) / 2;
                    gameState.particles.push({
                        x: midX + (Math.random() - 0.5) * 40,
                        y: midY + (Math.random() - 0.5) * 40,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 30,
                        maxLife: 30,
                        color: '#facc15'
                    });
                }
            }
        }

        function handleCollisionAnimation() {
            if (gameState.collisionShake > 20 && Math.random() < 0.4) {
                gameState.particles.push({
                    x: gameState.playerX + (Math.random() - 0.5) * 60,
                    y: gameState.playerY + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 40,
                    maxLife: 40,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)`
                });
            }
        }

        function updateParticles() {
            gameState.particles = gameState.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                const alpha = particle.life / particle.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                return particle.life > 0;
            });
        }

        function drawBackground() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 3; i++) {
                const x = (Date.now() * 0.05 + i * 200) % (canvas.width + 100);
                drawCloud(x, 50 + i * 30);
            }
            
            ctx.strokeStyle = '#15803d';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 20);
            ctx.lineTo(canvas.width, canvas.height - 20);
            ctx.stroke();
        }

        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 25, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        function startGame() {
            bgMusic.volume = 0.7; // Set background music volume to 70%
            bgMusic.play().catch(err => console.warn('Background music playback failed:', err));
            document.getElementById('startScreen').style.display = 'none';
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.level = 1;
            gameState.lives = 3;
            gameState.speed = 2;
            
            generateNewObstacle();
            updateUI();
            gameLoop();
        }

        function endGame() {
            bgMusic.pause();
            gameOverSound.play().catch(err => console.warn('Game over sound playback failed:', err));
            gameState.isPlaying = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalLevel').textContent = gameState.level;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            
            gameState = {
                score: 0,
                level: 1,
                lives: 3,
                isPlaying: false,
                currentQuestion: null,
                playerShape: 'square',
                playerX: 100,
                playerY: canvas.height / 2,
                obstacleX: canvas.width + 100,
                obstacleY: canvas.height / 2,
                speed: 2,
                answered: false,
                timeLeft: 100,
                merging: false,
                colliding: false,
                mergeProgress: 0,
                collisionShake: 0,
                playerScale: 1,
                obstacleScale: 1,
                particles: [],
                lastCorrectShape: null
            };
            
            startGame();
        }

        // Initialize game
        resizeCanvas();
    </script>
</body>
</html>